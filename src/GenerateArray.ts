import Validation from "./Validation.ts";

class GenerateArray {

    private static _characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    private static _charactersWithSpecial = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+/\\{}[]|;:\'",.<>?`~';

    /**
     * Generate an array of the specified length filled with undefined values
     * @param length Size of array
     */
    public static blank(length: number) {

        Validation.integer(length, 1, "length");

        return Array(length);
    }

    /**
     * Generate an array of the specified length filled with the specified value
     * @param length Size of array
     * @param value Value to fill array with
     */
    public static uniform(length: number, value: any) {

        Validation.integer(length, 1, "length");

        return Array(length).fill(value);
    }

    /**
     * Generate an array of the specified length filled with values generated by the given function
     *
     * Examples:
     * GenerateArray.custom(() => Math.random(), 5) -> [0.12345, 0.6789, 0.101112, 0.131415, 0.161718] (possible values)
     * GenerateArray.custom(() => Math.floor(Math.random() * 10), 6) -> [7, 2, 5, 9, 1, 3] (possible values)
     *
     * @param generator Function to generate each array value
     * @param length Size of array
     */
    public static custom = (generator: () => any, length: number): any[] => {

        Validation.function(generator, "generator");
        Validation.integer(length, 1, "length");

        return Array.from({ length }, generator);
    }

    /**
     * Generate an array of numbers from the start to end values (inclusive) with the given step value
     *
     * Examples:
     * GenerateArray.counting(0, 5) -> [0, 1, 2, 3, 4, 5]
     * GenerateArray.counting(1, 10, 2) -> [1, 3, 5, 7, 9]
     * GenerateArray.counting(1.2, 37.9, 4.7) -> [1.2, 5.9, 10.6, 15.3, 20, 24.7, 29.4, 34.1]
     *
     * @param start Number to start at
     * @param max Maximum highest value (will not be included if it's not a multiple of the step value plus the starting value)
     * @param step Value added at each step (default 1)
     */
    public static counting = (start: number, max: number, step: number = 1): number[] => {
        const result: number[] = [];
        for (let i = start; i <= max; i += step) {
            result.push(i);
        }
        return result;
    }

    /**
     * Generate an array of random integers of the specified length within the given range
     *
     * @param length Size of array (>= 1)
     * @param min Minimum value (inclusive), default 0
     * @param max Maximum value (exclusive), default 100
     */
    public static integers = (length: number, min: number = 0, max: number = 100) => {

        Validation.integer(length, 1, "length");

        if (min >= max) {
            throw new Error(`Parameter 'min' must be less than 'max': min '${min}' and max '${max}' are invalid`);
        }

        const range = max - min;
        return Array.from({ length }, () => Math.floor(Math.random() * range) + min);
    }

    /**
     * Generate an array of random decimals of the specified length within the given range
     *
     * Examples:
     * GenerateArray.decimals(5, 0, 1) -> [0.12345, 0.6789, 0.101112, 0.131415, 0.161718] (possible values)
     * GenerateArray.decimals(6, 0, 10) -> [7.12345, 2.6789, 5.101112, 9.131415, 1.161718, 3.192021] (possible values)
     *
     * @param length Size of array (>= 1)
     * @param min Minimum value (inclusive), default 0
     * @param max Maximum value (exclusive), default 1
     */
    public static decimals = (length: number, min: number = 0, max: number = 1) => {

        Validation.integer(length, -Infinity, "length");

        if (min >= max) {
            throw new Error(`Parameter 'min' must be less than 'max': min '${min}' and max '${max}' are invalid`);
        }

        const range = max - min;
        return Array.from({ length }, () => Math.random() * range + min);
    }

    /**
     * Generate an array of random strings of the specified length within the given range
     *
     * @param length Size of array (>= 1)
     * @param minLength Minimum length of string (>= 1)
     * @param maxLength Maximum length of string (>= minLength)
     * @param specialChars If true, includes special characters (!@#$%^&*()_+/\{}[]|;:'",.<>?`~) in the generated
     * strings. By default, only letters and numbers are used (a-zA-Z0-9)
     */
    public static strings = (length: number, minLength: number = 1, maxLength: number = 10, specialChars: boolean = false) => {

        Validation.integer(length, 1, "length");
        Validation.integer(minLength, 1, "minLength");
        Validation.integer(maxLength, minLength, "maxLength");

        const range = maxLength - minLength;
        const chars = specialChars ? this._charactersWithSpecial : this._characters;
        const charLength = chars.length;

        return Array.from({ length }, () => {
            const len = Math.floor(Math.random() * range) + minLength;
            return Array.from({ length: len }, () => chars[Math.floor(Math.random() * charLength)]).join("");
        });
    }

    // Helper for generating multidimensional arrays
    private static _deepArray = (baseArray: any[] | (() => any[]), length: number, depth: number): any[] => {
        if (depth === 1) {
            if (typeof baseArray === "function") {
                return baseArray();
            }
            return baseArray.slice();
        }

        return Array.from({ length }, () => this._deepArray(baseArray, length, depth - 1));
    }

    /**
     * Generates an array of arrays of the specific length (number of arrays in each array) and depth (how many
     * levels of arrays to generate before stopping) where the base array is empty.
     *
     * Examples:
     * GenerateArray.emptyND(1, 2) -> [[]] (Each array has 1 array in it, and there are 2 levels of arrays)
     * GenerateArray.emptyND(2, 2) -> [[], []] (Each array has 2 arrays in it, and there are 2 levels of arrays)
     * GenerateArray.emptyND(1, 3) -> [[[]]] (There is 1 array in each array, and 3 levels of arrays)
     * GenerateArray.emptyND(2, 3) -> [[[], []], [[], []]] (There are 2 arrays in each array, and 3 levels of arrays)
     *
     * @param length Number of arrays in each array (>= 1), excluding the base array (array at the lowest depth)
     * @param depth Dimension of the returned array (>= 2), i.e. how many layers of arrays there are. Depth of 1
     * isn't allowed to reduce confusion as it would just be on empty array ([]) regardless of the length.
     */
    public static emptyND = (length: number, depth: number): [][] => {

        Validation.integer(length, 1, "length");
        Validation.integer(depth, 2, "depth");

        return this._deepArray([], length, depth);
    }

    /**
     * Generates an array of arrays of the specific length (number of arrays in each array) and depth (how many
     * levels of arrays to generate before stopping) where all base arrays are filled with the given value(s).
     *
     * If the value is an array, the base arrays will be filled with the values of the array instead of adding an
     * extra depth of arrays, e.g. 7 -> [7], [1, 2, 3] -> [1, 2, 3] (put the array in an array if you'd like this)
     *
     * Examples:
     * GenerateArray.customND(7, 3, 2) -> [[7], [7], [7]]
     * GenerateArray.customND([1, 2, 3], 3, 2) -> [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
     *
     * @param value Value of the base array. If not an array, the base array will be an array filled with this value.
     * @param length Number of arrays in each array (>= 1), excluding the base array (array at the lowest depth)
     * @param depth Dimension of the returned array (>= 2), i.e. how many layers of arrays there are. Depth of 1
     * isn't included to reduce confusion, as it would just return the value in an array (or the value if it's an array)
     * e.g. MultidimensionalArray.uniform([1, 2, 3], 3, 1) -> [1, 2, 3]
     */
    public static uniformND = (value: any, length: number, depth: number): any[] => {

        Validation.integer(length, 1, "length");
        Validation.integer(depth, 2, "depth");

        const baseArray = [];
        if (Array.isArray(value)) {
            baseArray.push(...value);
        } else {
            baseArray.push(value);
        }

        return this._deepArray(baseArray, length, depth);
    }

    /**
     * Generates an array of arrays of the specific length (number of arrays in each array) and depth (how many
     * levels of arrays to generate before stopping) where the base arrays are generated by the given function.
     *
     * Examples:
     * GenerateArray.customND(() => Math.floor(Math.random() * 10), 3, 2) -> [[7], [2], [5]] (possible output)
     *
     * @param generator Function to generate the base array. Note this function is called once for each base array,
     * so to have multiple values, this function should return an array of multiple values (e.g.
     * GenerateArray.custom(() => [1, 2, 3], len, depth))
     * @param length Number of arrays in each array (>= 1), excluding the base array (array at the lowest depth)
     * @param depth Dimension of the returned array (>= 2), i.e. how many layers of arrays there are. Depth of 1 isn't
     * allowed to reduce confusion as it would just put the value of one function call in an array, e.g. () => 7 -> [7]
     * (to get a 1-D array with multiple values, use GenerateArray.custom(() => ..., len) instead)
     */
    public static customND = (generator: () => any[], length: number, depth: number): any[] => {

        Validation.function(generator, "generator", true);
        Validation.integer(length, 1, "length");
        Validation.integer(depth, 2, "depth");

        return this._deepArray(generator, length, depth);
    }
}

export default GenerateArray;
