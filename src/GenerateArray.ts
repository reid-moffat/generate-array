import Validation from "./Validation.ts";
import GenerateArrayError from "./GenerateArrayError.ts";

class GenerateArray {
    /**
     * Generate an array of the specified length filled with undefined values
     * @param length Size of array
     */
    public static blank(length: number) {

        Validation.integer(length, 1, "length");

        return Array(length);
    }

    /**
     * Generate an array of the specified length filled with the specified value
     * @param length Size of array
     * @param value Value to fill array with
     */
    public static uniform(length: number, value: any) {

        Validation.integer(length, 1, "length");

        return Array(length).fill(value);
    }

    /**
     * Generate an array of the specified length filled with values generated by the given function
     *
     * Examples:
     * GenerateArray.custom(() => Math.random(), 5) -> [0.12345, 0.6789, 0.101112, 0.131415, 0.161718] (possible values)
     * GenerateArray.custom(() => Math.floor(Math.random() * 10), 6) -> [7, 2, 5, 9, 1, 3] (possible values)
     *
     * @param generator Function to generate each array value
     * @param length Size of array
     */
    public static custom = (generator: () => any, length: number): any[] => {

        Validation.function(generator, "generator");
        Validation.integer(length, 1, "length");

        return Array.from({ length }, generator);
    }

    /**
     * Generate an array of integers starting from the start to end values (inclusive) with the given step value
     *
     * @param start
     * @param end
     * @param step
     */
    public static counting = (start: number, end: number, step = 1): number[] => {

        Validation.integer(start, 0, "start");
        Validation.integer(end, 0, "end");
        Validation.integer(step, 1, "step");

        const length = Math.ceil((end - start) / step + 1);
        return Array.from({ length }, (_, i) => start + i * step);
    }

    /**
     * Generate an array of random integers of the specified length within the given range
     *
     * @param length
     * @param min
     * @param max
     */
    public static numbers = (length: number, min: number = 0, max: number = 100) => {
        ;
    }

    /**
     * Generate an array of random decimals of the specified length within the given range
     *
     * Examples:
     * GenerateArray.decimals(5, 0, 1) -> [0.12345, 0.6789, 0.101112, 0.131415, 0.161718] (possible values)
     * GenerateArray.decimals(6, 0, 10) -> [7.12345, 2.6789, 5.101112, 9.131415, 1.161718, 3.192021] (possible values)
     *
     * @param length Size of array (>= 1)
     * @param min Minimum value (inclusive)
     * @param max Maximum value (exclusive)
     */
    public static decimals = (length: number, min: number = 0, max: number = 1) => {

        Validation.integer(length, 1, "length");
        if (typeof min !== "number" || typeof max !== "number") {
            throw new GenerateArrayError("Parameters 'min' and 'max' must be numbers");
        }
        if (min >= max) {
            throw new Error(`Parameter 'min' must be less than 'max': min '${min}' and max '${max}' are invalid`);
        }

        const range = max - min;
        return Array.from({ length }, () => Math.random() * range + min);
    }

    // Helper for generating multidimensional arrays
    private static _deepArray = (baseArray: any[] | (() => any[]), length: number, depth: number): any[] => {
        if (depth === 1) {
            if (typeof baseArray === "function") {
                return baseArray();
            }
            return baseArray.slice();
        }

        return Array.from({ length }, () => this._deepArray(baseArray, length, depth - 1));
    }

    /**
     * Generates an array of arrays of the specific length (number of arrays in each array) and depth (how many
     * levels of arrays to generate before stopping) where the base array is empty.
     *
     * Examples:
     * GenerateArray.emptyND(1, 2) -> [[]] (Each array has 1 array in it, and there are 2 levels of arrays)
     * GenerateArray.emptyND(2, 2) -> [[], []] (Each array has 2 arrays in it, and there are 2 levels of arrays)
     * GenerateArray.emptyND(1, 3) -> [[[]]] (There is 1 array in each array, and 3 levels of arrays)
     * GenerateArray.emptyND(2, 3) -> [[[], []], [[], []]] (There are 2 arrays in each array, and 3 levels of arrays)
     *
     * @param length Number of arrays in each array (>= 1), excluding the base array (array at the lowest depth)
     * @param depth Dimension of the returned array (>= 2), i.e. how many layers of arrays there are. Depth of 1
     * isn't allowed to reduce confusion as it would just be on empty array ([]) regardless of the length.
     */
    public static emptyND = (length: number, depth: number): [][] => {

        Validation.integer(length, 1, "length");
        Validation.integer(depth, 2, "depth");

        return this._deepArray([], length, depth);
    }

    /**
     * Generates an array of arrays of the specific length (number of arrays in each array) and depth (how many
     * levels of arrays to generate before stopping) where all base arrays are filled with the given value(s).
     *
     * If the value is an array, the base arrays will be filled with the values of the array instead of adding an
     * extra depth of arrays, e.g. 7 -> [7], [1, 2, 3] -> [1, 2, 3] (put the array in an array if you'd like this)
     *
     * Examples:
     * GenerateArray.customND(7, 3, 2) -> [[7], [7], [7]]
     * GenerateArray.customND([1, 2, 3], 3, 2) -> [[1, 2, 3], [1, 2, 3], [1, 2, 3]]
     *
     * @param value Value of the base array. If not an array, the base array will be an array filled with this value.
     * @param length Number of arrays in each array (>= 1), excluding the base array (array at the lowest depth)
     * @param depth Dimension of the returned array (>= 2), i.e. how many layers of arrays there are. Depth of 1
     * isn't included to reduce confusion, as it would just return the value in an array (or the value if it's an array)
     * e.g. MultidimensionalArray.uniform([1, 2, 3], 3, 1) -> [1, 2, 3]
     */
    public static uniformND = (value: any, length: number, depth: number): any[] => {

        Validation.integer(length, 1, "length");
        Validation.integer(depth, 2, "depth");

        const baseArray = [];
        if (Array.isArray(value)) {
            baseArray.push(...value);
        } else {
            baseArray.push(value);
        }

        return this._deepArray(baseArray, length, depth);
    }

    /**
     * Generates an array of arrays of the specific length (number of arrays in each array) and depth (how many
     * levels of arrays to generate before stopping) where the base arrays are generated by the given function.
     *
     * Examples:
     * GenerateArray.customND(() => Math.floor(Math.random() * 10), 3, 2) -> [[7], [2], [5]] (possible output)
     *
     * @param generator Function to generate the base array. Note this function is called once for each base array,
     * so to have multiple values, this function should return an array of multiple values (e.g.
     * GenerateArray.custom(() => [1, 2, 3], len, depth))
     * @param length Number of arrays in each array (>= 1), excluding the base array (array at the lowest depth)
     * @param depth Dimension of the returned array (>= 2), i.e. how many layers of arrays there are. Depth of 1 isn't
     * allowed to reduce confusion as it would just put the value of one function call in an array, e.g. () => 7 -> [7]
     * (to get a 1-D array with multiple values, use GenerateArray.custom(() => ..., len) instead)
     */
    public static customND = (generator: () => any[], length: number, depth: number): any[] => {

        Validation.function(generator, "generator", true);
        Validation.integer(length, 1, "length");
        Validation.integer(depth, 2, "depth");

        return this._deepArray(generator, length, depth);
    }
}

export default GenerateArray;
